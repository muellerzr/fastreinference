# AUTOGENERATED! DO NOT EDIT! File to edit: 00_typing.ipynb (unless otherwise specified).

__all__ = ['Member', 'Mem', 'Documented', 'Doc', 'FunctionalEnum', 'DocumentedEnum', 'multiassert', 'enumify']

# Cell
import enum
import inspect
import typing
from functools import wraps, partial

# Cell
class Member:
    """Annotation only type to be used within `@enumify`.

    Used to denote when a member will be of type `str`,
    with the value being its member name in lowercase.
    """
    def __init__(self, *args):
        raise TypeError("Member is a documentation type, cannot be instantiated")

Mem = Member

# Cell
class Documented:
    """Annotation only type to be used within `@enumify`.

    Used to denote when a member will have a docstring as its last assert.
    """
    def __init__(self, *args):
        raise TypeError("Documented is a documentation type, cannot be instantiated")

Doc = Documented

# Cell
class FunctionalEnum(enum.Enum):
    """
    An `Enum` class implementing `__ne__`, `__eq__`, and `__str__` to compare `self.value`.

    Compatible with the functional API.
    """
    def __str__(self): return str(self.value)
    def __eq__(self, other): return getattr(other, "value", other) == self.value
    def __ne__(self, other): return getattr(other, "value", other) != self.value

# Cell
class DocumentedEnum(FunctionalEnum):
    """
    An `Enum` capabile of having its members have docstrings.

    Inherits `FunctionalEnum` to allow for logic comparison via `==`, `!=`,
    and string representation `str()` of `self.value`.
    """
    def __init__(self, *args):
        """
        Creates a generic enumeration with assigning of a member docstring

        Should be passed in the form of:
          docstring, value
        """
        if args[0] is not None:
            self.__doc__ = args[0]
        if len(args) > 1:
            self._value_ = args[1]
        else:
            self._value_ = None

# Cell
def multiassert(type, types:list=[]):
    """Runs `==` on all `types`

    If any are `True`, returns `True`.
    """
    for t in types:
        if t == type:
            return True
    return False

# Cell
def _assign_annotations(cls):
    """
    Creates a `DocumentedEnum` based on annotations and asserts in `cls`
    """
    # First, filter out all but what we need: the doc, annotations, and any set members
    d = dict(cls.__dict__)
    _keep = ["__doc__", "__annotations__"]
    for key in list(d):
        if key.startswith('_') and key not in _keep:
            d.pop(key, None)
    names = [] # Names for our enum
    keys = []
    # Next get our members with out values
    for name, typ in list(d["__annotations__"].items()):
        if not multiassert(typ, [Member, Documented, tuple[Member, Documented]]):
            continue
        if typ == tuple[Member, Documented]:
            doc = getattr(cls, name)
            value = name.lower()
        elif typ == Documented:
            value, doc = getattr(cls, name)
        else: # Emplicit else for raw Member
            doc = "An enumeration."
            value = name.lower()
        names.append([name, (doc, value)])
        keys.append(name)

    # For any values set like a regular enum
    for name in d:
        if name not in keys and not name.startswith("_"):
            names.append([name, ("An enumeration.", getattr(cls, name))])
            keys.append(name)
    new_cls = DocumentedEnum(value=cls.__name__, names=names)
    new_cls.__doc__ = cls.__doc__
    return new_cls

# Cell
def enumify(cls=None):
    """
    A decorator to turn `cls` into an Enum class with member values as property names, and potentially with documentation

    Should be documented with the `Member` type with the following annotation:
    ```python
    from .typing import Member
    @enumify
    class MyClass:
      NAME:Member["Some documented enum value"]
      name_two:Member # An undocumented enum value
      name_three:Member["Some documentation"] = "some value"
    ```

    Can also use the shorthand `Mem` type
    """
    def wrap(cls): return _assign_annotations(cls)
    if cls is None:
        return partial(enumify)
    return wrap(cls)