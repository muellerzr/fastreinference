# AUTOGENERATED! DO NOT EDIT! File to edit: 99_utils.ipynb (unless otherwise specified).

__all__ = ['SelfEnum']

# Cell
import enum
from typing import Any
from functools import wraps, partial

# Cell
class _DocumentedEnum(enum.Enum):
    """
    An `Enum` capabile of having its members have docstrings, compatible with the functional API
    """
    def __init__(self, *args):
        """
        Creates a generic enumeration with potential assigning of a member docstring

        Should be passed in the form of:
          value, docstring
        """
        if len(args) == 2:
            # Have value, docstring
            self._value_, self.__doc__ = args
        else:
            # Just value
            self._value_ = args[0]

    def __str__(self): return str(self.value)
    def __eq__(self, other): return getattr(other, "value", other) == self.value
    def __ne__(self, other): return getattr(other, "value", other) != self.value

# Cell
def _assign_annotations(cls, special=None):
    """
    Creates a `_DocumentedEnum` based on annotations in `cls`
    """
    cls_annotations = cls.__dict__.get("__annotations__", {})
    names = []
    for name, typ in list(cls_annotations.items()):
        member = [name]
        value = name.lower()
        cls_annotations.pop(name)
        doc = getattr(cls, name, None)
        if doc is not None:
            member.append((value,doc))
        else:
            member.append(value)
        names.append(member)
    if special is not None:
        for name in special:
            value, doc = getattr(cls, name, None)
            names.append([name, (value, doc)])
    return _DocumentedEnum(value=cls.__name__, names=names)

# Cell
def SelfEnum(cls=None, *, special:list=None):
    """
    A decorator to turn `cls` into an Enum class with member values as property names.
    If a type is specified, the resulting Enum will subclass it.

    If any Enum member is defined as a regular tuple of (value, doc), they should be passed in
    to `special`

    Classes should use the following annotation when defining them:
    ```python
    from typing import Any
    class MyClass:
      NAME:Any = "Some documented enum value"
      name_two:Any # An undocumented enum value
    ```
    """
    def wrap(cls, special=None): return _assign_annotations(cls, special)

    if cls is None and special is None:
        return wrap
    if not isinstance(special, list) and special is not None:
        special = [special]
    if cls is None:
        return partial(SelfEnum, special=special)
    return wrap(cls, special)